{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyACI","text":"<p>scrapli -- scrap(e c)li --  is a python library focused on connecting to devices, specifically network devices  (routers/switches/firewalls/etc.) via SSH or Telnet. The name scrapli -- is just \"scrape cli\" (as in screen scrape)  squished together! scrapli's goal is to be as fast and flexible as possible, while providing a thoroughly tested, well   typed, well documented, simple API that supports both synchronous and asynchronous usage.</p> <p>Feel free to join the very awesome networktocode slack workspace here, where you  will find a <code>scrapli</code> channel where you can discuss anything about scrapli, as well as tons of other channels covering   all sorts of network/network-automation topics!</p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>Thanks for thinking about contributing! Contributions are not expected, but are quite welcome.</p> <p>Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds.</p> <p>Some notes on contributing:</p> <ul> <li>Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR,   this way everyone has a chance to chime in and make sure we're all on the same page!</li> <li>Please open an issue to discuss any bugs/bug fixes prior to opening a PR.</li> <li>Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated!</li> <li>All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing.</li> <li>Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future    don't break functionality or make things act in unexpected ways!</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>core<ul> <li>endpoint</li> <li>query</li> <li>response</li> </ul> </li> </ul>"},{"location":"reference/core/","title":"core","text":""},{"location":"reference/core/endpoint/","title":"endpoint","text":"<p>(c) 2017 DigitalOcean</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/core/endpoint/#core.endpoint.DetailEndpoint","title":"<code>DetailEndpoint</code>","text":"<p>Enables read/write operations on detail endpoints.</p> <p>Endpoints like <code>available-ips</code> that are detail routes off traditional endpoints are handled with this class.</p> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>class DetailEndpoint:\n    \"\"\"Enables read/write operations on detail endpoints.\n\n    Endpoints like `available-ips` that are detail routes off\n    traditional endpoints are handled with this class.\n    \"\"\"\n\n    def __init__(self, parent_obj, name, custom_return=None):\n        self.parent_obj = parent_obj\n        self.custom_return = custom_return\n        self.url = \"{}/{}/{}/\".format(parent_obj.endpoint.url, parent_obj.id, name)\n        self.request_kwargs = dict(\n            base=self.url,\n            token=parent_obj.api.token,\n            http_session=parent_obj.api.http_session,\n        )\n\n    def list(self, **kwargs):\n        \"\"\"The view operation for a detail endpoint.\n\n        Returns the response from NetBox for a detail endpoint.\n\n        ## Parameters\n\n        * **kwargs**: Key/value pairs that get converted into URL\n            parameters when passed to the endpoint.\n            E.g. `.list(method='get_facts')` would be converted to\n            `.../?method=get_facts`.\n\n        ## Returns\n        A Record object or list of Record objects created\n        from data retrieved from Aci.\n        \"\"\"\n        req = Request(**self.request_kwargs).get(add_params=kwargs)\n\n        if self.custom_return:\n            return [\n                self.custom_return(\n                    i, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n                for i in req\n            ]\n        return req\n\n    def create(self, data=None):\n        \"\"\"The write operation for a detail endpoint.\n\n        Creates objects on a detail endpoint in Aci.\n\n        ## Parameters\n\n        * **data** (dict/list, optional): A dictionary containing the\n            key/value pair of the items you're creating on the parent\n            object. Defaults to empty dict which will create a single\n            item with default values.\n\n        ## Returns\n        A Record object or list of Record objects created\n        from data created in Aci.\n        \"\"\"\n        data = data or {}\n        req = Request(**self.request_kwargs).post(data)\n        if self.custom_return:\n            if isinstance(req, list):\n                return [\n                    self.custom_return(\n                        req_item, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                    )\n                    for req_item in req\n                ]\n            else:\n                return self.custom_return(\n                    req, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n        return req\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.DetailEndpoint.create","title":"<code>create(data=None)</code>","text":"<p>The write operation for a detail endpoint.</p> <p>Creates objects on a detail endpoint in Aci.</p>"},{"location":"reference/core/endpoint/#core.endpoint.DetailEndpoint.create--parameters","title":"Parameters","text":"<ul> <li>data (dict/list, optional): A dictionary containing the     key/value pair of the items you're creating on the parent     object. Defaults to empty dict which will create a single     item with default values.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.DetailEndpoint.create--returns","title":"Returns","text":"<p>A Record object or list of Record objects created from data created in Aci.</p> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def create(self, data=None):\n    \"\"\"The write operation for a detail endpoint.\n\n    Creates objects on a detail endpoint in Aci.\n\n    ## Parameters\n\n    * **data** (dict/list, optional): A dictionary containing the\n        key/value pair of the items you're creating on the parent\n        object. Defaults to empty dict which will create a single\n        item with default values.\n\n    ## Returns\n    A Record object or list of Record objects created\n    from data created in Aci.\n    \"\"\"\n    data = data or {}\n    req = Request(**self.request_kwargs).post(data)\n    if self.custom_return:\n        if isinstance(req, list):\n            return [\n                self.custom_return(\n                    req_item, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n                for req_item in req\n            ]\n        else:\n            return self.custom_return(\n                req, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n            )\n    return req\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.DetailEndpoint.list","title":"<code>list(**kwargs)</code>","text":"<p>The view operation for a detail endpoint.</p> <p>Returns the response from NetBox for a detail endpoint.</p>"},{"location":"reference/core/endpoint/#core.endpoint.DetailEndpoint.list--parameters","title":"Parameters","text":"<ul> <li>kwargs: Key/value pairs that get converted into URL     parameters when passed to the endpoint.     E.g. <code>.list(method='get_facts')</code> would be converted to     <code>.../?method=get_facts</code>.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.DetailEndpoint.list--returns","title":"Returns","text":"<p>A Record object or list of Record objects created from data retrieved from Aci.</p> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def list(self, **kwargs):\n    \"\"\"The view operation for a detail endpoint.\n\n    Returns the response from NetBox for a detail endpoint.\n\n    ## Parameters\n\n    * **kwargs**: Key/value pairs that get converted into URL\n        parameters when passed to the endpoint.\n        E.g. `.list(method='get_facts')` would be converted to\n        `.../?method=get_facts`.\n\n    ## Returns\n    A Record object or list of Record objects created\n    from data retrieved from Aci.\n    \"\"\"\n    req = Request(**self.request_kwargs).get(add_params=kwargs)\n\n    if self.custom_return:\n        return [\n            self.custom_return(\n                i, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n            )\n            for i in req\n        ]\n    return req\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint","title":"<code>Endpoint</code>","text":"<p>Represent actions available on endpoints in the Netbox API.</p> <p>Takes <code>name</code> and <code>app</code> passed from App() and builds the correct url to make queries to and the proper Response object to return results in.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint--parameters","title":"Parameters","text":"<ul> <li>api (Api): Takes Api created at instantiation.</li> <li>app (App): Takes App.</li> <li>name (str): Name of endpoint passed to App().</li> <li>model (obj, optional): Custom model for given app.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint--note","title":"Note","text":"<p>In order to call NetBox endpoints with dashes in their names you should convert the dash to an underscore. (E.g. querying the ip-addresses endpoint is done with <code>aci.ipam.ip_addresses.all()</code>.)</p> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>class Endpoint:\n    \"\"\"Represent actions available on endpoints in the Netbox API.\n\n    Takes ``name`` and ``app`` passed from App() and builds the correct\n    url to make queries to and the proper Response object to return\n    results in.\n\n    ## Parameters\n\n    * **api** (Api): Takes Api created at instantiation.\n    * **app** (App): Takes App.\n    * **name** (str): Name of endpoint passed to App().\n    * **model** (obj, optional): Custom model for given app.\n\n    ## Note\n\n    In order to call NetBox endpoints with dashes in their\n    names you should convert the dash to an underscore.\n    (E.g. querying the ip-addresses endpoint is done with\n    ``aci.ipam.ip_addresses.all()``.)\n    \"\"\"\n\n    def __init__(self, api, app, name, model=None):\n        self.return_obj = self._lookup_ret_obj(name, model)\n        self.name = name.replace(\"_\", \"-\")\n        self.api = api\n        self.app = app\n        self.base_url = api.base_url\n        self.token = api.token\n        self.url = \"{base_url}/{app}/{endpoint}\".format(\n            base_url=self.base_url,\n            app=app.name,\n            endpoint=self.name,\n        )\n        self._choices = None\n\n    def _lookup_ret_obj(self, name, model):\n        \"\"\"Loads unique Response objects.\n\n        This method loads a unique response object for an endpoint if\n        it exists. Otherwise return a generic `Record` object.\n\n        ## Parameters\n\n        * **name** (str): Endpoint name.\n        * **model** (obj): The application model that contains unique Record objects.\n\n        ## Returns\n        Record (obj)\n        \"\"\"\n        if model:\n            name = name.title().replace(\"_\", \"\")\n            ret = getattr(model, name, Record)\n        else:\n            ret = Record\n        return ret\n\n    def _validate_openapi_parameters(self, method: str, parameters: dict) -&gt; None:\n        \"\"\"Validate GET request parameters against OpenAPI specification\n\n        This method raises a **ParameterValidationError** if parameters passed to NetBox API\n        do not match the OpenAPI specification or validation fails.\n\n        ## Parameters\n\n        * **method** : Only \"get\" is supported as for other methods NetBox already does proper validation\n        * **parameters** : kwargs passed to filter() method\n\n        ## Returns\n        None\n        \"\"\"\n        if method.lower() != \"get\":\n            raise RuntimeError(f\"Unsupported method '{method}'.\")\n\n        openapi_definition_path = \"/api/{app}/{endpoint}/\".format(\n            app=self.app.name,\n            endpoint=self.name,\n        )\n\n        # Parse NetBox OpenAPI definition\n        try:\n            openapi_definition = self.api.openapi()[\"paths\"].get(\n                openapi_definition_path\n            )\n\n            if not openapi_definition:\n                raise ParameterValidationError(\n                    f\"Path '{openapi_definition_path}' does not exist in NetBox OpenAPI specification.\"\n                )\n\n            openapi_parameters = openapi_definition[method][\"parameters\"]\n            allowed_parameters = [p[\"name\"] for p in openapi_parameters]\n\n        except KeyError as exc:\n            raise ParameterValidationError(\n                f\"Error while parsing Netbox OpenAPI specification: {exc}\"\n            )\n\n        # Validate all parameters\n        validation_errors = []\n        for p in parameters:\n            if p not in allowed_parameters:\n                validation_errors.append(\n                    f\"'{p}' is not allowed as parameter on path '{openapi_definition_path}'.\"\n                )\n\n        if len(validation_errors) &gt; 0:\n            raise ParameterValidationError(validation_errors)\n\n    def all(self, limit=0, offset=None):\n        \"\"\"Queries the 'ListView' of a given endpoint.\n\n        Returns all objects from an endpoint.\n\n        ## Parameters\n\n        * **limit** (int, optional): Overrides the max page size on\n            paginated returns. This defines the number of records that will\n            be returned with each query to the Netbox server. The queries\n            will be made as you iterate through the result set.\n        * **offset** (int, optional): Overrides the offset on paginated returns.\n\n        ## Returns\n        A RecordSet object.\n\n        ## Examples\n\n        ```python\n        devices = list(aci.dcim.devices.all())\n        for device in devices:\n            print(device.name)\n\n        # test1-leaf1\n        # test1-leaf2\n        # test1-leaf3\n        ```\n\n        If you want to iterate over the results multiple times then\n        encapsulate them in a list like this:\n        ```python\n        devices = list(aci.dcim.devices.all())\n        ```\n\n        This will cause the entire result set\n        to be fetched from the server.\n        \"\"\"\n        if limit == 0 and offset is not None:\n            raise ValueError(\"offset requires a positive limit value\")\n        req = Request(\n            base=\"{}/\".format(self.url),\n            token=self.token,\n            http_session=self.api.http_session,\n            threading=self.api.threading,\n            limit=limit,\n            offset=offset,\n        )\n\n        return RecordSet(self, req)\n\n    def get(self, *args, **kwargs):\n        \"\"\"Queries the DetailsView of a given endpoint.\n\n        ## Parameters\n\n        * **key** (int, optional): id for the item to be retrieved.\n        * **kwargs**: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can\n            be added as a keyword arg.\n        * **strict_filters** (bool, optional): Overrides the global filter\n            validation per-request basis. Handled by the filter() method.\n\n        ## Returns\n        A single Record object or None\n\n        ## Raises\n        ValueError: if kwarg search return more than one value.\n\n        ## Examples\n\n        Referencing with a kwarg that only returns one value:\n\n        ```python\n        aci.dcim.devices.get(name='test1-a3-tor1b')\n        # test1-a3-tor1b\n        ```\n\n        Referencing with an id:\n\n        ```python\n        aci.dcim.devices.get(1)\n        # test1-edge1\n        ```\n\n        Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:\n\n        ```python\n        aci.locations.get(site='site-1', name='Row 1')\n        # Row 1\n        ```\n        \"\"\"\n        try:\n            key = args[0]\n        except IndexError:\n            key = None\n\n        if not key:\n            resp = self.filter(**kwargs)\n            ret = next(resp, None)\n            if not ret:\n                return ret\n            try:\n                next(resp)\n                raise ValueError(\n                    \"get() returned more than one result. \"\n                    \"Check that the kwarg(s) passed are valid for this \"\n                    \"endpoint or use filter() or all() instead.\"\n                )\n            except StopIteration:\n                return ret\n\n        req = Request(\n            key=key,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n        try:\n            return next(RecordSet(self, req), None)\n        except RequestError as e:\n            if e.req.status_code == 404:\n                return None\n            else:\n                raise e\n\n    def filter(self, *args, **kwargs):\n        \"\"\"Queries the 'ListView' of a given endpoint.\n\n        Takes named arguments that match the usable filters on a\n        given endpoint. If an argument is passed then it's used as a\n        freeform search argument if the endpoint supports it.\n\n        ## Parameters\n\n        * **args** (str, optional): Freeform search string that's\n            accepted on given endpoint.\n        * **kwargs** (str, optional): Any search argument the\n            endpoint accepts can be added as a keyword arg.\n        * **limit** (int, optional): Overrides the max page size on\n            paginated returns. This defines the number of records that will\n            be returned with each query to the Netbox server. The queries\n            will be made as you iterate through the result set.\n        * **offset** (int, optional): Overrides the offset on paginated returns.\n        * **strict_filters** (bool, optional): Overrides the global filter\n            validation per-request basis.\n\n        ## Returns\n        A RecordSet object.\n\n        ## Examples\n\n        To return a list of objects matching a named argument filter:\n\n        ```python\n        devices = aci.dcim.devices.filter(role='leaf-switch')\n        for device in devices:\n            print(device.name)\n\n        # test1-leaf1\n        # test1-leaf2\n        # test1-leaf3\n        ```\n\n        ```python\n        devices = aci.dcim.devices.filter(site='site-1')\n        for device in devices:\n            print(device.name)\n\n        # test1-a2-leaf1\n        # test2-a2-leaf2\n        ```\n\n        ## Note\n\n        If a keyword argument is incorrect a `TypeError` will not be returned by aci.\n        Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used `site=\"Site 1\"` instead of `site=site-1` when using filter on\n        the devices endpoint, then pynetbox will return **all** devices across all sites instead of devices at Site 1.\n\n        Using a freeform query along with a named argument:\n\n        ```python\n        devices = aci.dcim.devices.filter('a3', role='leaf-switch')\n        for device in devices:\n            print(device.name)\n\n        # test1-a3-leaf1\n        # test1-a3-leaf2\n        ```\n        \"\"\"\n\n        if args:\n            kwargs.update({\"q\": args[0]})\n\n        if any(i in RESERVED_KWARGS for i in kwargs):\n            raise ValueError(\n                \"A reserved kwarg was passed ({}). Please remove it \"\n                \"and try again.\".format(RESERVED_KWARGS)\n            )\n        limit = kwargs.pop(\"limit\") if \"limit\" in kwargs else 0\n        offset = kwargs.pop(\"offset\") if \"offset\" in kwargs else None\n        strict_filters = (\n            # kwargs value takes precedence on globally set value\n            kwargs.pop(\"strict_filters\")\n            if \"strict_filters\" in kwargs\n            else self.api.strict_filters\n        )\n\n        if limit == 0 and offset is not None:\n            raise ValueError(\"offset requires a positive limit value\")\n        filters = {x: y if y is not None else \"null\" for x, y in kwargs.items()}\n\n        if strict_filters:\n            self._validate_openapi_parameters(\"get\", filters)\n\n        req = Request(\n            filters=filters,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n            threading=self.api.threading,\n            limit=limit,\n            offset=offset,\n        )\n\n        return RecordSet(self, req)\n\n    def create(self, *args, **kwargs):\n        \"\"\"Creates an object on an endpoint.\n\n        Takes named arguments that match the given endpoint's\n        available fields. Returns a new object.\n\n        ## Parameters\n\n        * **args**: Not used.\n        * **kwargs**: Fields and values to create the object with.\n\n        ## Returns\n        A Record object.\n\n        ## Examples\n\n        Creating a new device:\n\n        ```python\n        new_device = aci.dcim.devices.create(\n            name='test-device',\n            device_type=1,\n            device_role=1,\n            site=1\n        )\n        ```\n\n        Creating a new device with a nested object:\n\n        ```python\n        new_device = aci.dcim.devices.create(\n            name='test-device',\n            device_type={'id': 1},\n            device_role={'id': 1},\n            site={'id': 1}\n        )\n        ```\n        \"\"\"\n\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        ).post(args[0] if args else kwargs)\n\n        if isinstance(req, list):\n            return [self.return_obj(i, self.api, self) for i in req]\n        return self.return_obj(req, self.api, self)\n\n    def update(self, objects):\n        \"\"\"Updates objects in Aci.\n\n        Takes a list of objects and updates them in Aci.\n\n        ## Parameters\n\n        * **objects** (list): A list of Record objects to update.\n\n        ## Returns\n        A list of Record objects.\n\n        ## Examples\n\n        ```python\n        devices = aci.dcim.devices.filter(site='test1')\n        for device in devices:\n            device.status = 'active'\n        aci.dcim.devices.update(devices)\n        ```\n        \"\"\"\n        series = []\n        if not isinstance(objects, list):\n            raise ValueError(\n                \"Objects passed must be list[dict|Record] - was {}\".format(\n                    type(objects)\n                )\n            )\n        for o in objects:\n            if isinstance(o, Record):\n                data = o.updates()\n                if data:\n                    data[\"id\"] = o.id\n                    series.append(data)\n            elif isinstance(o, dict):\n                if \"id\" not in o:\n                    raise ValueError(\"id is missing from object: \" + str(o))\n                series.append(o)\n            else:\n                raise ValueError(\n                    \"Object passed must be dict|Record - was {}\".format(type(objects))\n                )\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        ).patch(series)\n\n        if isinstance(req, list):\n            return [self.return_obj(i, self.api, self) for i in req]\n        return self.return_obj(req, self.api, self)\n\n    def delete(self, objects):\n        \"\"\"Deletes objects from Aci.\n\n        Takes a list of objects and deletes them from Aci.\n\n        ## Parameters\n\n        * **objects** (list): A list of Record objects to delete.\n\n        ## Returns\n        True if the delete operation was successful.\n\n        ## Examples\n\n        ```python\n        devices = aci.dcim.devices.filter(site='test1')\n        aci.dcim.devices.delete(devices)\n        ```\n        \"\"\"\n        cleaned_ids = []\n        if not isinstance(objects, list) and not isinstance(objects, RecordSet):\n            raise ValueError(\n                \"objects must be list[str|int|Record]\"\n                \"|RecordSet - was \" + str(type(objects))\n            )\n        for o in objects:\n            if isinstance(o, int):\n                cleaned_ids.append(o)\n            elif isinstance(o, str) and o.isnumeric():\n                cleaned_ids.append(int(o))\n            elif isinstance(o, Record):\n                if not hasattr(o, \"id\"):\n                    raise ValueError(\n                        \"Record from '\"\n                        + o.url\n                        + \"' does not have an id and cannot be bulk deleted\"\n                    )\n                cleaned_ids.append(o.id)\n            else:\n                raise ValueError(\n                    \"Invalid object in list of objects to delete: \" + str(type(o))\n                )\n\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n        return True if req.delete(data=[{\"id\": i} for i in cleaned_ids]) else False\n\n    def choices(self):\n        \"\"\"Returns all choices from the endpoint if it has them.\n\n        ## Returns\n        Dictionary of available choices.\n\n        ## Examples\n\n        ```python\n        choices = aci.dcim.devices.choices()\n        print(choices['status'])\n        {\n            'label': 'Active',\n            'value': 'active'\n        }\n        ```\n        \"\"\"\n        if self._choices:\n            return self._choices\n\n        req = Request(\n            base=self.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        ).options()\n\n        actions = req.get(\"actions\", {})\n        post_data = actions.get(\"POST\") or actions.get(\"PUT\")\n        if post_data is None:\n            raise ValueError(\n                \"Unexpected format in the OPTIONS response at {}\".format(self.url)\n            )\n        self._choices = {}\n        for prop in post_data:\n            if \"choices\" in post_data[prop]:\n                self._choices[prop] = post_data[prop][\"choices\"]\n\n        return self._choices\n\n    def count(self, *args, **kwargs):\n        \"\"\"Returns the count of objects in a query.\n\n        Takes named arguments that match the usable filters on a\n        given endpoint. If an argument is passed then it's used as a\n        freeform search argument if the endpoint supports it.\n\n        ## Parameters\n\n        * **args** (str, optional): Freeform search string that's\n            accepted on given endpoint.\n        * **kwargs** (str, optional): Any search argument the\n            endpoint accepts can be added as a keyword arg.\n\n        ## Returns\n        Integer of count of objects.\n\n        ## Examples\n\n        ```python\n        aci.dcim.devices.count(site='test1')\n        # 27\n        ```\n        \"\"\"\n\n        if args:\n            kwargs.update({\"q\": args[0]})\n\n        if any(i in RESERVED_KWARGS for i in kwargs):\n            raise ValueError(\n                \"A reserved {} kwarg was passed. Please remove it \"\n                \"try again.\".format(RESERVED_KWARGS)\n            )\n\n        ret = Request(\n            filters=kwargs,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n\n        return ret.get_count()\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.all","title":"<code>all(limit=0, offset=None)</code>","text":"<p>Queries the 'ListView' of a given endpoint.</p> <p>Returns all objects from an endpoint.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.all--parameters","title":"Parameters","text":"<ul> <li>limit (int, optional): Overrides the max page size on     paginated returns. This defines the number of records that will     be returned with each query to the Netbox server. The queries     will be made as you iterate through the result set.</li> <li>offset (int, optional): Overrides the offset on paginated returns.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.all--returns","title":"Returns","text":"<p>A RecordSet object.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.all--examples","title":"Examples","text":"<pre><code>devices = list(aci.dcim.devices.all())\nfor device in devices:\n    print(device.name)\n\n# test1-leaf1\n# test1-leaf2\n# test1-leaf3\n</code></pre> <p>If you want to iterate over the results multiple times then encapsulate them in a list like this: <pre><code>devices = list(aci.dcim.devices.all())\n</code></pre></p> <p>This will cause the entire result set to be fetched from the server.</p> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def all(self, limit=0, offset=None):\n    \"\"\"Queries the 'ListView' of a given endpoint.\n\n    Returns all objects from an endpoint.\n\n    ## Parameters\n\n    * **limit** (int, optional): Overrides the max page size on\n        paginated returns. This defines the number of records that will\n        be returned with each query to the Netbox server. The queries\n        will be made as you iterate through the result set.\n    * **offset** (int, optional): Overrides the offset on paginated returns.\n\n    ## Returns\n    A RecordSet object.\n\n    ## Examples\n\n    ```python\n    devices = list(aci.dcim.devices.all())\n    for device in devices:\n        print(device.name)\n\n    # test1-leaf1\n    # test1-leaf2\n    # test1-leaf3\n    ```\n\n    If you want to iterate over the results multiple times then\n    encapsulate them in a list like this:\n    ```python\n    devices = list(aci.dcim.devices.all())\n    ```\n\n    This will cause the entire result set\n    to be fetched from the server.\n    \"\"\"\n    if limit == 0 and offset is not None:\n        raise ValueError(\"offset requires a positive limit value\")\n    req = Request(\n        base=\"{}/\".format(self.url),\n        token=self.token,\n        http_session=self.api.http_session,\n        threading=self.api.threading,\n        limit=limit,\n        offset=offset,\n    )\n\n    return RecordSet(self, req)\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.choices","title":"<code>choices()</code>","text":"<p>Returns all choices from the endpoint if it has them.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.choices--returns","title":"Returns","text":"<p>Dictionary of available choices.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.choices--examples","title":"Examples","text":"<pre><code>choices = aci.dcim.devices.choices()\nprint(choices['status'])\n{\n    'label': 'Active',\n    'value': 'active'\n}\n</code></pre> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def choices(self):\n    \"\"\"Returns all choices from the endpoint if it has them.\n\n    ## Returns\n    Dictionary of available choices.\n\n    ## Examples\n\n    ```python\n    choices = aci.dcim.devices.choices()\n    print(choices['status'])\n    {\n        'label': 'Active',\n        'value': 'active'\n    }\n    ```\n    \"\"\"\n    if self._choices:\n        return self._choices\n\n    req = Request(\n        base=self.url,\n        token=self.api.token,\n        http_session=self.api.http_session,\n    ).options()\n\n    actions = req.get(\"actions\", {})\n    post_data = actions.get(\"POST\") or actions.get(\"PUT\")\n    if post_data is None:\n        raise ValueError(\n            \"Unexpected format in the OPTIONS response at {}\".format(self.url)\n        )\n    self._choices = {}\n    for prop in post_data:\n        if \"choices\" in post_data[prop]:\n            self._choices[prop] = post_data[prop][\"choices\"]\n\n    return self._choices\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.count","title":"<code>count(*args, **kwargs)</code>","text":"<p>Returns the count of objects in a query.</p> <p>Takes named arguments that match the usable filters on a given endpoint. If an argument is passed then it's used as a freeform search argument if the endpoint supports it.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.count--parameters","title":"Parameters","text":"<ul> <li>args (str, optional): Freeform search string that's     accepted on given endpoint.</li> <li>kwargs (str, optional): Any search argument the     endpoint accepts can be added as a keyword arg.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.count--returns","title":"Returns","text":"<p>Integer of count of objects.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.count--examples","title":"Examples","text":"<pre><code>aci.dcim.devices.count(site='test1')\n# 27\n</code></pre> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def count(self, *args, **kwargs):\n    \"\"\"Returns the count of objects in a query.\n\n    Takes named arguments that match the usable filters on a\n    given endpoint. If an argument is passed then it's used as a\n    freeform search argument if the endpoint supports it.\n\n    ## Parameters\n\n    * **args** (str, optional): Freeform search string that's\n        accepted on given endpoint.\n    * **kwargs** (str, optional): Any search argument the\n        endpoint accepts can be added as a keyword arg.\n\n    ## Returns\n    Integer of count of objects.\n\n    ## Examples\n\n    ```python\n    aci.dcim.devices.count(site='test1')\n    # 27\n    ```\n    \"\"\"\n\n    if args:\n        kwargs.update({\"q\": args[0]})\n\n    if any(i in RESERVED_KWARGS for i in kwargs):\n        raise ValueError(\n            \"A reserved {} kwarg was passed. Please remove it \"\n            \"try again.\".format(RESERVED_KWARGS)\n        )\n\n    ret = Request(\n        filters=kwargs,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n\n    return ret.get_count()\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.create","title":"<code>create(*args, **kwargs)</code>","text":"<p>Creates an object on an endpoint.</p> <p>Takes named arguments that match the given endpoint's available fields. Returns a new object.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.create--parameters","title":"Parameters","text":"<ul> <li>args: Not used.</li> <li>kwargs: Fields and values to create the object with.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.create--returns","title":"Returns","text":"<p>A Record object.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.create--examples","title":"Examples","text":"<p>Creating a new device:</p> <pre><code>new_device = aci.dcim.devices.create(\n    name='test-device',\n    device_type=1,\n    device_role=1,\n    site=1\n)\n</code></pre> <p>Creating a new device with a nested object:</p> <pre><code>new_device = aci.dcim.devices.create(\n    name='test-device',\n    device_type={'id': 1},\n    device_role={'id': 1},\n    site={'id': 1}\n)\n</code></pre> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def create(self, *args, **kwargs):\n    \"\"\"Creates an object on an endpoint.\n\n    Takes named arguments that match the given endpoint's\n    available fields. Returns a new object.\n\n    ## Parameters\n\n    * **args**: Not used.\n    * **kwargs**: Fields and values to create the object with.\n\n    ## Returns\n    A Record object.\n\n    ## Examples\n\n    Creating a new device:\n\n    ```python\n    new_device = aci.dcim.devices.create(\n        name='test-device',\n        device_type=1,\n        device_role=1,\n        site=1\n    )\n    ```\n\n    Creating a new device with a nested object:\n\n    ```python\n    new_device = aci.dcim.devices.create(\n        name='test-device',\n        device_type={'id': 1},\n        device_role={'id': 1},\n        site={'id': 1}\n    )\n    ```\n    \"\"\"\n\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    ).post(args[0] if args else kwargs)\n\n    if isinstance(req, list):\n        return [self.return_obj(i, self.api, self) for i in req]\n    return self.return_obj(req, self.api, self)\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.delete","title":"<code>delete(objects)</code>","text":"<p>Deletes objects from Aci.</p> <p>Takes a list of objects and deletes them from Aci.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.delete--parameters","title":"Parameters","text":"<ul> <li>objects (list): A list of Record objects to delete.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.delete--returns","title":"Returns","text":"<p>True if the delete operation was successful.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.delete--examples","title":"Examples","text":"<pre><code>devices = aci.dcim.devices.filter(site='test1')\naci.dcim.devices.delete(devices)\n</code></pre> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def delete(self, objects):\n    \"\"\"Deletes objects from Aci.\n\n    Takes a list of objects and deletes them from Aci.\n\n    ## Parameters\n\n    * **objects** (list): A list of Record objects to delete.\n\n    ## Returns\n    True if the delete operation was successful.\n\n    ## Examples\n\n    ```python\n    devices = aci.dcim.devices.filter(site='test1')\n    aci.dcim.devices.delete(devices)\n    ```\n    \"\"\"\n    cleaned_ids = []\n    if not isinstance(objects, list) and not isinstance(objects, RecordSet):\n        raise ValueError(\n            \"objects must be list[str|int|Record]\"\n            \"|RecordSet - was \" + str(type(objects))\n        )\n    for o in objects:\n        if isinstance(o, int):\n            cleaned_ids.append(o)\n        elif isinstance(o, str) and o.isnumeric():\n            cleaned_ids.append(int(o))\n        elif isinstance(o, Record):\n            if not hasattr(o, \"id\"):\n                raise ValueError(\n                    \"Record from '\"\n                    + o.url\n                    + \"' does not have an id and cannot be bulk deleted\"\n                )\n            cleaned_ids.append(o.id)\n        else:\n            raise ValueError(\n                \"Invalid object in list of objects to delete: \" + str(type(o))\n            )\n\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n    return True if req.delete(data=[{\"id\": i} for i in cleaned_ids]) else False\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.filter","title":"<code>filter(*args, **kwargs)</code>","text":"<p>Queries the 'ListView' of a given endpoint.</p> <p>Takes named arguments that match the usable filters on a given endpoint. If an argument is passed then it's used as a freeform search argument if the endpoint supports it.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.filter--parameters","title":"Parameters","text":"<ul> <li>args (str, optional): Freeform search string that's     accepted on given endpoint.</li> <li>kwargs (str, optional): Any search argument the     endpoint accepts can be added as a keyword arg.</li> <li>limit (int, optional): Overrides the max page size on     paginated returns. This defines the number of records that will     be returned with each query to the Netbox server. The queries     will be made as you iterate through the result set.</li> <li>offset (int, optional): Overrides the offset on paginated returns.</li> <li>strict_filters (bool, optional): Overrides the global filter     validation per-request basis.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.filter--returns","title":"Returns","text":"<p>A RecordSet object.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.filter--examples","title":"Examples","text":"<p>To return a list of objects matching a named argument filter:</p> <pre><code>devices = aci.dcim.devices.filter(role='leaf-switch')\nfor device in devices:\n    print(device.name)\n\n# test1-leaf1\n# test1-leaf2\n# test1-leaf3\n</code></pre> <pre><code>devices = aci.dcim.devices.filter(site='site-1')\nfor device in devices:\n    print(device.name)\n\n# test1-a2-leaf1\n# test2-a2-leaf2\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.filter--note","title":"Note","text":"<p>If a keyword argument is incorrect a <code>TypeError</code> will not be returned by aci. Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used <code>site=\"Site 1\"</code> instead of <code>site=site-1</code> when using filter on the devices endpoint, then pynetbox will return all devices across all sites instead of devices at Site 1.</p> <p>Using a freeform query along with a named argument:</p> <pre><code>devices = aci.dcim.devices.filter('a3', role='leaf-switch')\nfor device in devices:\n    print(device.name)\n\n# test1-a3-leaf1\n# test1-a3-leaf2\n</code></pre> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def filter(self, *args, **kwargs):\n    \"\"\"Queries the 'ListView' of a given endpoint.\n\n    Takes named arguments that match the usable filters on a\n    given endpoint. If an argument is passed then it's used as a\n    freeform search argument if the endpoint supports it.\n\n    ## Parameters\n\n    * **args** (str, optional): Freeform search string that's\n        accepted on given endpoint.\n    * **kwargs** (str, optional): Any search argument the\n        endpoint accepts can be added as a keyword arg.\n    * **limit** (int, optional): Overrides the max page size on\n        paginated returns. This defines the number of records that will\n        be returned with each query to the Netbox server. The queries\n        will be made as you iterate through the result set.\n    * **offset** (int, optional): Overrides the offset on paginated returns.\n    * **strict_filters** (bool, optional): Overrides the global filter\n        validation per-request basis.\n\n    ## Returns\n    A RecordSet object.\n\n    ## Examples\n\n    To return a list of objects matching a named argument filter:\n\n    ```python\n    devices = aci.dcim.devices.filter(role='leaf-switch')\n    for device in devices:\n        print(device.name)\n\n    # test1-leaf1\n    # test1-leaf2\n    # test1-leaf3\n    ```\n\n    ```python\n    devices = aci.dcim.devices.filter(site='site-1')\n    for device in devices:\n        print(device.name)\n\n    # test1-a2-leaf1\n    # test2-a2-leaf2\n    ```\n\n    ## Note\n\n    If a keyword argument is incorrect a `TypeError` will not be returned by aci.\n    Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used `site=\"Site 1\"` instead of `site=site-1` when using filter on\n    the devices endpoint, then pynetbox will return **all** devices across all sites instead of devices at Site 1.\n\n    Using a freeform query along with a named argument:\n\n    ```python\n    devices = aci.dcim.devices.filter('a3', role='leaf-switch')\n    for device in devices:\n        print(device.name)\n\n    # test1-a3-leaf1\n    # test1-a3-leaf2\n    ```\n    \"\"\"\n\n    if args:\n        kwargs.update({\"q\": args[0]})\n\n    if any(i in RESERVED_KWARGS for i in kwargs):\n        raise ValueError(\n            \"A reserved kwarg was passed ({}). Please remove it \"\n            \"and try again.\".format(RESERVED_KWARGS)\n        )\n    limit = kwargs.pop(\"limit\") if \"limit\" in kwargs else 0\n    offset = kwargs.pop(\"offset\") if \"offset\" in kwargs else None\n    strict_filters = (\n        # kwargs value takes precedence on globally set value\n        kwargs.pop(\"strict_filters\")\n        if \"strict_filters\" in kwargs\n        else self.api.strict_filters\n    )\n\n    if limit == 0 and offset is not None:\n        raise ValueError(\"offset requires a positive limit value\")\n    filters = {x: y if y is not None else \"null\" for x, y in kwargs.items()}\n\n    if strict_filters:\n        self._validate_openapi_parameters(\"get\", filters)\n\n    req = Request(\n        filters=filters,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n        threading=self.api.threading,\n        limit=limit,\n        offset=offset,\n    )\n\n    return RecordSet(self, req)\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.get","title":"<code>get(*args, **kwargs)</code>","text":"<p>Queries the DetailsView of a given endpoint.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.get--parameters","title":"Parameters","text":"<ul> <li>key (int, optional): id for the item to be retrieved.</li> <li>kwargs: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can     be added as a keyword arg.</li> <li>strict_filters (bool, optional): Overrides the global filter     validation per-request basis. Handled by the filter() method.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.get--returns","title":"Returns","text":"<p>A single Record object or None</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.get--raises","title":"Raises","text":"<p>ValueError: if kwarg search return more than one value.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.get--examples","title":"Examples","text":"<p>Referencing with a kwarg that only returns one value:</p> <pre><code>aci.dcim.devices.get(name='test1-a3-tor1b')\n# test1-a3-tor1b\n</code></pre> <p>Referencing with an id:</p> <pre><code>aci.dcim.devices.get(1)\n# test1-edge1\n</code></pre> <p>Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:</p> <pre><code>aci.locations.get(site='site-1', name='Row 1')\n# Row 1\n</code></pre> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def get(self, *args, **kwargs):\n    \"\"\"Queries the DetailsView of a given endpoint.\n\n    ## Parameters\n\n    * **key** (int, optional): id for the item to be retrieved.\n    * **kwargs**: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can\n        be added as a keyword arg.\n    * **strict_filters** (bool, optional): Overrides the global filter\n        validation per-request basis. Handled by the filter() method.\n\n    ## Returns\n    A single Record object or None\n\n    ## Raises\n    ValueError: if kwarg search return more than one value.\n\n    ## Examples\n\n    Referencing with a kwarg that only returns one value:\n\n    ```python\n    aci.dcim.devices.get(name='test1-a3-tor1b')\n    # test1-a3-tor1b\n    ```\n\n    Referencing with an id:\n\n    ```python\n    aci.dcim.devices.get(1)\n    # test1-edge1\n    ```\n\n    Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:\n\n    ```python\n    aci.locations.get(site='site-1', name='Row 1')\n    # Row 1\n    ```\n    \"\"\"\n    try:\n        key = args[0]\n    except IndexError:\n        key = None\n\n    if not key:\n        resp = self.filter(**kwargs)\n        ret = next(resp, None)\n        if not ret:\n            return ret\n        try:\n            next(resp)\n            raise ValueError(\n                \"get() returned more than one result. \"\n                \"Check that the kwarg(s) passed are valid for this \"\n                \"endpoint or use filter() or all() instead.\"\n            )\n        except StopIteration:\n            return ret\n\n    req = Request(\n        key=key,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n    try:\n        return next(RecordSet(self, req), None)\n    except RequestError as e:\n        if e.req.status_code == 404:\n            return None\n        else:\n            raise e\n</code></pre>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.update","title":"<code>update(objects)</code>","text":"<p>Updates objects in Aci.</p> <p>Takes a list of objects and updates them in Aci.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.update--parameters","title":"Parameters","text":"<ul> <li>objects (list): A list of Record objects to update.</li> </ul>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.update--returns","title":"Returns","text":"<p>A list of Record objects.</p>"},{"location":"reference/core/endpoint/#core.endpoint.Endpoint.update--examples","title":"Examples","text":"<pre><code>devices = aci.dcim.devices.filter(site='test1')\nfor device in devices:\n    device.status = 'active'\naci.dcim.devices.update(devices)\n</code></pre> Source code in <code>pyaci/core/endpoint.py</code> <pre><code>def update(self, objects):\n    \"\"\"Updates objects in Aci.\n\n    Takes a list of objects and updates them in Aci.\n\n    ## Parameters\n\n    * **objects** (list): A list of Record objects to update.\n\n    ## Returns\n    A list of Record objects.\n\n    ## Examples\n\n    ```python\n    devices = aci.dcim.devices.filter(site='test1')\n    for device in devices:\n        device.status = 'active'\n    aci.dcim.devices.update(devices)\n    ```\n    \"\"\"\n    series = []\n    if not isinstance(objects, list):\n        raise ValueError(\n            \"Objects passed must be list[dict|Record] - was {}\".format(\n                type(objects)\n            )\n        )\n    for o in objects:\n        if isinstance(o, Record):\n            data = o.updates()\n            if data:\n                data[\"id\"] = o.id\n                series.append(data)\n        elif isinstance(o, dict):\n            if \"id\" not in o:\n                raise ValueError(\"id is missing from object: \" + str(o))\n            series.append(o)\n        else:\n            raise ValueError(\n                \"Object passed must be dict|Record - was {}\".format(type(objects))\n            )\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    ).patch(series)\n\n    if isinstance(req, list):\n        return [self.return_obj(i, self.api, self) for i in req]\n    return self.return_obj(req, self.api, self)\n</code></pre>"},{"location":"reference/core/query/","title":"query","text":""},{"location":"reference/core/query/#core.query.ParameterValidationError","title":"<code>ParameterValidationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>API parameter validation Exception.</p> <p>Raised when filter parameters do not match Netbox OpenAPI specification.</p>"},{"location":"reference/core/query/#core.query.ParameterValidationError--examples","title":"Examples","text":"<pre><code>try:\n    nb.dcim.devices.filter(field_which_does_not_exist=\"destined-for-failure\")\nexcept pynetbox.ParameterValidationError as e:\n    print(e.error)\n</code></pre> Source code in <code>pyaci/core/query.py</code> <pre><code>class ParameterValidationError(Exception):\n    \"\"\"API parameter validation Exception.\n\n    Raised when filter parameters do not match Netbox OpenAPI specification.\n\n    ## Examples\n\n    ```python\n    try:\n        nb.dcim.devices.filter(field_which_does_not_exist=\"destined-for-failure\")\n    except pynetbox.ParameterValidationError as e:\n        print(e.error)\n    ```\n    \"\"\"\n\n    def __init__(self, errors):\n        super().__init__(errors)\n        self.error = f\"The request parameter validation returned an error: {errors}\"\n\n    def __str__(self):\n        return self.error\n</code></pre>"},{"location":"reference/core/query/#core.query.Request","title":"<code>Request</code>","text":"<p>Creates requests to the ACI API.</p> <p>Responsible for building the url and making the HTTP(S) requests to ACI's API.</p>"},{"location":"reference/core/query/#core.query.Request--parameters","title":"Parameters","text":"<ul> <li>base (str): Base URL passed in api() instantiation.</li> <li>filters (dict, optional): Contains key/value pairs that     correlate to the filters a given endpoint accepts.     In (e.g. /api/dcim/devices/?name='test') 'name': 'test'     would be in the filters dict.</li> </ul> Source code in <code>pyaci/core/query.py</code> <pre><code>class Request:\n    \"\"\"Creates requests to the ACI API.\n\n    Responsible for building the url and making the HTTP(S) requests to\n    ACI's API.\n\n    ## Parameters\n\n    * **base** (str): Base URL passed in api() instantiation.\n    * **filters** (dict, optional): Contains key/value pairs that\n        correlate to the filters a given endpoint accepts.\n        In (e.g. /api/dcim/devices/?name='test') 'name': 'test'\n        would be in the filters dict.\n    \"\"\"\n\n    def __init__(\n        self,\n        base,\n        http_session,\n        filters=None,\n        limit=None,\n        offset=None,\n        key=None,\n        token=None,\n        threading=False,\n    ):\n        \"\"\"Instantiates a new Request object.\n\n        ## Parameters\n\n        * **base** (string): Base URL passed in api() instantiation.\n        * **filters** (dict, optional): Contains key/value pairs that\n            correlate to the filters a given endpoint accepts.\n            In (e.g. /api/dcim/devices/?name='test') 'name': 'test'\n            would be in the filters dict.\n        * **key** (int, optional): Database id of the item being queried.\n        \"\"\"\n        self.base = self.normalize_url(base)\n        self.filters = filters or None\n        self.key = key\n        self.token = token\n        self.http_session = http_session\n        self.url = self.base if not key else f\"{self.base}{key}/\"\n        self.threading = threading\n        self.limit = limit\n        self.offset = offset\n\n    def get_openapi(self):\n        \"\"\"Gets the OpenAPI Spec.\"\"\"\n        headers = {\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n        }\n\n        current_version = version.parse(self.get_version())\n        if current_version &gt;= version.parse(\"3.5\"):\n            req = self.http_session.get(\n                \"{}schema/\".format(self.normalize_url(self.base)),\n                headers=headers,\n            )\n        else:\n            req = self.http_session.get(\n                \"{}docs/?format=openapi\".format(self.normalize_url(self.base)),\n                headers=headers,\n            )\n\n        if req.ok:\n            return req.json()\n        else:\n            raise RequestError(req)\n\n\n    def get_version(self):\n        \"\"\"Gets the API version of ACI.\n\n        Issues a GET request to the base URL to read the API version from the\n        response headers.\n\n        ## Returns\n        Version number as a string. Empty string if version is not\n        present in the headers.\n\n        ## Raises\n        RequestError if req.ok returns false.\n        \"\"\"\n        headers = {\n            \"Content-Type\": \"application/json\",\n        }\n        req = self.http_session.get(\n            self.normalize_url(self.base),\n            headers=headers,\n        )\n        if req.ok or req.status_code == 403:\n            return req.headers.get(\"API-Version\", \"\")\n        else:\n            raise RequestError(req)\n\n    def normalize_url(self, url):\n        \"\"\"Builds a url for POST actions.\"\"\"\n        if url[-1] != \"/\":\n            return f\"{url}/\"\n\n        return url\n\n    def _make_call(self, verb=\"get\", url_override=None, add_params=None, data=None):\n        if verb in (\"post\", \"put\") or verb == \"delete\" and data:\n            headers = {\"Content-Type\": \"application/json\"}\n        else:\n            headers = {\"accept\": \"application/json\"}\n\n        if self.token:\n            headers[\"authorization\"] = \"Token {}\".format(self.token)\n\n        params = {}\n        if not url_override:\n            if self.filters:\n                params.update(self.filters)\n            if add_params:\n                params.update(add_params)\n\n        req = getattr(self.http_session, verb)(\n            url_override or self.url, headers=headers, params=params, json=data\n        )\n\n        if req.status_code == 409 and verb == \"post\":\n            raise AllocationError(req)\n        if verb == \"delete\":\n            if req.ok:\n                return True\n            else:\n                raise RequestError(req)\n        elif req.ok:\n            try:\n                return req.json()\n            except json.JSONDecodeError:\n                raise ContentError(req)\n        else:\n            raise RequestError(req)\n\n    def get(self, add_params=None):\n        \"\"\"Makes a GET request.\n\n        Makes a GET request to NetBox's API, and automatically recurses\n        any paginated results.\n\n        ## Returns\n        List of `Response` objects returned from the endpoint.\n\n        ## Raises\n        * RequestError if req.ok returns false.\n        * ContentError if response is not json.\n        \"\"\"\n\n        if not add_params and self.limit is not None:\n            add_params = {\"limit\": self.limit}\n            if self.limit and self.offset is not None:\n                # if non-zero limit and some offset -&gt; add offset\n                add_params[\"offset\"] = self.offset\n        req = self._make_call(add_params=add_params)\n        if isinstance(req, dict) and req.get(\"results\") is not None:\n            self.count = req[\"count\"]\n            if self.offset is not None:\n                # only yield requested page results if paginating\n                for i in req[\"results\"]:\n                    yield i\n            elif self.threading:\n                ret = req[\"results\"]\n                if req.get(\"next\"):\n                    page_size = len(req[\"results\"])\n                    pages = calc_pages(page_size, req[\"count\"])\n                    page_offsets = [\n                        increment * page_size for increment in range(1, pages)\n                    ]\n                    if pages == 1:\n                        req = self._make_call(url_override=req.get(\"next\"))\n                        ret.extend(req[\"results\"])\n                    else:\n                        self.concurrent_get(ret, page_size, page_offsets)\n                for i in ret:\n                    yield i\n            else:\n                first_run = True\n                for i in req[\"results\"]:\n                    yield i\n                while req[\"next\"]:\n                    # Not worrying about making sure add_params kwargs is\n                    # passed in here because results from detail routes aren't\n                    # paginated, thus far.\n                    if first_run:\n                        req = self._make_call(\n                            add_params={\n                                \"limit\": self.limit or req[\"count\"],\n                                \"offset\": len(req[\"results\"]),\n                            }\n                        )\n                    else:\n                        req = self._make_call(url_override=req[\"next\"])\n                    first_run = False\n                    for i in req[\"results\"]:\n                        yield i\n        elif isinstance(req, list):\n            self.count = len(req)\n            for i in req:\n                yield i\n        else:\n            self.count = len(req)\n            yield req\n\n    def put(self, data):\n        \"\"\"Makes PUT request.\n\n        Makes a PUT request to NetBox's API.\n\n        ## Parameters\n        * **data** (dict): Contains a dict that will be turned into a\n            json object and sent to the API.\n\n        ## Returns\n        Dict containing the response from NetBox's API.\n\n        ## Raises\n        * RequestError if req.ok returns false.\n        * ContentError if response is not json.\n        \"\"\"\n        return self._make_call(verb=\"put\", data=data)\n\n    def post(self, data):\n        \"\"\"Makes POST request.\n\n        Makes a POST request to NetBox's API.\n\n        ## Parameters\n        * **data** (dict): Contains a dict that will be turned into a\n            json object and sent to the API.\n\n        ## Returns\n        Dict containing the response from NetBox's API.\n\n        ## Raises\n        * RequestError if req.ok returns false.\n        * AllocationError if req.status_code is 409 (Conflict)\n            as with available-ips and available-prefixes when there is\n            no room for the requested allocation.\n        * ContentError if response is not json.\n        \"\"\"\n        return self._make_call(verb=\"post\", data=data)\n\n    def delete(self, data=None):\n        \"\"\"Makes DELETE request.\n\n        Makes a DELETE request to NetBox's API.\n\n        ## Parameters\n        * **data** (list): Contains a dict that will be turned into a\n            json object and sent to the API.\n\n        ## Returns\n        True if successful.\n\n        ## Raises\n        RequestError if req.ok doesn't return True.\n        \"\"\"\n        return self._make_call(verb=\"delete\", data=data)\n\n    def patch(self, data):\n        \"\"\"Makes PATCH request.\n\n        Makes a PATCH request to NetBox's API.\n\n        ## Parameters\n        * **data** (dict): Contains a dict that will be turned into a\n            json object and sent to the API.\n\n        ## Returns\n        Dict containing the response from NetBox's API.\n\n        ## Raises\n        * RequestError if req.ok returns false.\n        * ContentError if response is not json.\n        \"\"\"\n        return self._make_call(verb=\"patch\", data=data)\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.__init__","title":"<code>__init__(base, http_session, filters=None, limit=None, offset=None, key=None, token=None, threading=False)</code>","text":"<p>Instantiates a new Request object.</p>"},{"location":"reference/core/query/#core.query.Request.__init__--parameters","title":"Parameters","text":"<ul> <li>base (string): Base URL passed in api() instantiation.</li> <li>filters (dict, optional): Contains key/value pairs that     correlate to the filters a given endpoint accepts.     In (e.g. /api/dcim/devices/?name='test') 'name': 'test'     would be in the filters dict.</li> <li>key (int, optional): Database id of the item being queried.</li> </ul> Source code in <code>pyaci/core/query.py</code> <pre><code>def __init__(\n    self,\n    base,\n    http_session,\n    filters=None,\n    limit=None,\n    offset=None,\n    key=None,\n    token=None,\n    threading=False,\n):\n    \"\"\"Instantiates a new Request object.\n\n    ## Parameters\n\n    * **base** (string): Base URL passed in api() instantiation.\n    * **filters** (dict, optional): Contains key/value pairs that\n        correlate to the filters a given endpoint accepts.\n        In (e.g. /api/dcim/devices/?name='test') 'name': 'test'\n        would be in the filters dict.\n    * **key** (int, optional): Database id of the item being queried.\n    \"\"\"\n    self.base = self.normalize_url(base)\n    self.filters = filters or None\n    self.key = key\n    self.token = token\n    self.http_session = http_session\n    self.url = self.base if not key else f\"{self.base}{key}/\"\n    self.threading = threading\n    self.limit = limit\n    self.offset = offset\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.delete","title":"<code>delete(data=None)</code>","text":"<p>Makes DELETE request.</p> <p>Makes a DELETE request to NetBox's API.</p>"},{"location":"reference/core/query/#core.query.Request.delete--parameters","title":"Parameters","text":"<ul> <li>data (list): Contains a dict that will be turned into a     json object and sent to the API.</li> </ul>"},{"location":"reference/core/query/#core.query.Request.delete--returns","title":"Returns","text":"<p>True if successful.</p>"},{"location":"reference/core/query/#core.query.Request.delete--raises","title":"Raises","text":"<p>RequestError if req.ok doesn't return True.</p> Source code in <code>pyaci/core/query.py</code> <pre><code>def delete(self, data=None):\n    \"\"\"Makes DELETE request.\n\n    Makes a DELETE request to NetBox's API.\n\n    ## Parameters\n    * **data** (list): Contains a dict that will be turned into a\n        json object and sent to the API.\n\n    ## Returns\n    True if successful.\n\n    ## Raises\n    RequestError if req.ok doesn't return True.\n    \"\"\"\n    return self._make_call(verb=\"delete\", data=data)\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.get","title":"<code>get(add_params=None)</code>","text":"<p>Makes a GET request.</p> <p>Makes a GET request to NetBox's API, and automatically recurses any paginated results.</p>"},{"location":"reference/core/query/#core.query.Request.get--returns","title":"Returns","text":"<p>List of <code>Response</code> objects returned from the endpoint.</p>"},{"location":"reference/core/query/#core.query.Request.get--raises","title":"Raises","text":"<ul> <li>RequestError if req.ok returns false.</li> <li>ContentError if response is not json.</li> </ul> Source code in <code>pyaci/core/query.py</code> <pre><code>def get(self, add_params=None):\n    \"\"\"Makes a GET request.\n\n    Makes a GET request to NetBox's API, and automatically recurses\n    any paginated results.\n\n    ## Returns\n    List of `Response` objects returned from the endpoint.\n\n    ## Raises\n    * RequestError if req.ok returns false.\n    * ContentError if response is not json.\n    \"\"\"\n\n    if not add_params and self.limit is not None:\n        add_params = {\"limit\": self.limit}\n        if self.limit and self.offset is not None:\n            # if non-zero limit and some offset -&gt; add offset\n            add_params[\"offset\"] = self.offset\n    req = self._make_call(add_params=add_params)\n    if isinstance(req, dict) and req.get(\"results\") is not None:\n        self.count = req[\"count\"]\n        if self.offset is not None:\n            # only yield requested page results if paginating\n            for i in req[\"results\"]:\n                yield i\n        elif self.threading:\n            ret = req[\"results\"]\n            if req.get(\"next\"):\n                page_size = len(req[\"results\"])\n                pages = calc_pages(page_size, req[\"count\"])\n                page_offsets = [\n                    increment * page_size for increment in range(1, pages)\n                ]\n                if pages == 1:\n                    req = self._make_call(url_override=req.get(\"next\"))\n                    ret.extend(req[\"results\"])\n                else:\n                    self.concurrent_get(ret, page_size, page_offsets)\n            for i in ret:\n                yield i\n        else:\n            first_run = True\n            for i in req[\"results\"]:\n                yield i\n            while req[\"next\"]:\n                # Not worrying about making sure add_params kwargs is\n                # passed in here because results from detail routes aren't\n                # paginated, thus far.\n                if first_run:\n                    req = self._make_call(\n                        add_params={\n                            \"limit\": self.limit or req[\"count\"],\n                            \"offset\": len(req[\"results\"]),\n                        }\n                    )\n                else:\n                    req = self._make_call(url_override=req[\"next\"])\n                first_run = False\n                for i in req[\"results\"]:\n                    yield i\n    elif isinstance(req, list):\n        self.count = len(req)\n        for i in req:\n            yield i\n    else:\n        self.count = len(req)\n        yield req\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.get_openapi","title":"<code>get_openapi()</code>","text":"<p>Gets the OpenAPI Spec.</p> Source code in <code>pyaci/core/query.py</code> <pre><code>def get_openapi(self):\n    \"\"\"Gets the OpenAPI Spec.\"\"\"\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    current_version = version.parse(self.get_version())\n    if current_version &gt;= version.parse(\"3.5\"):\n        req = self.http_session.get(\n            \"{}schema/\".format(self.normalize_url(self.base)),\n            headers=headers,\n        )\n    else:\n        req = self.http_session.get(\n            \"{}docs/?format=openapi\".format(self.normalize_url(self.base)),\n            headers=headers,\n        )\n\n    if req.ok:\n        return req.json()\n    else:\n        raise RequestError(req)\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.get_version","title":"<code>get_version()</code>","text":"<p>Gets the API version of ACI.</p> <p>Issues a GET request to the base URL to read the API version from the response headers.</p>"},{"location":"reference/core/query/#core.query.Request.get_version--returns","title":"Returns","text":"<p>Version number as a string. Empty string if version is not present in the headers.</p>"},{"location":"reference/core/query/#core.query.Request.get_version--raises","title":"Raises","text":"<p>RequestError if req.ok returns false.</p> Source code in <code>pyaci/core/query.py</code> <pre><code>def get_version(self):\n    \"\"\"Gets the API version of ACI.\n\n    Issues a GET request to the base URL to read the API version from the\n    response headers.\n\n    ## Returns\n    Version number as a string. Empty string if version is not\n    present in the headers.\n\n    ## Raises\n    RequestError if req.ok returns false.\n    \"\"\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n    }\n    req = self.http_session.get(\n        self.normalize_url(self.base),\n        headers=headers,\n    )\n    if req.ok or req.status_code == 403:\n        return req.headers.get(\"API-Version\", \"\")\n    else:\n        raise RequestError(req)\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.normalize_url","title":"<code>normalize_url(url)</code>","text":"<p>Builds a url for POST actions.</p> Source code in <code>pyaci/core/query.py</code> <pre><code>def normalize_url(self, url):\n    \"\"\"Builds a url for POST actions.\"\"\"\n    if url[-1] != \"/\":\n        return f\"{url}/\"\n\n    return url\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.patch","title":"<code>patch(data)</code>","text":"<p>Makes PATCH request.</p> <p>Makes a PATCH request to NetBox's API.</p>"},{"location":"reference/core/query/#core.query.Request.patch--parameters","title":"Parameters","text":"<ul> <li>data (dict): Contains a dict that will be turned into a     json object and sent to the API.</li> </ul>"},{"location":"reference/core/query/#core.query.Request.patch--returns","title":"Returns","text":"<p>Dict containing the response from NetBox's API.</p>"},{"location":"reference/core/query/#core.query.Request.patch--raises","title":"Raises","text":"<ul> <li>RequestError if req.ok returns false.</li> <li>ContentError if response is not json.</li> </ul> Source code in <code>pyaci/core/query.py</code> <pre><code>def patch(self, data):\n    \"\"\"Makes PATCH request.\n\n    Makes a PATCH request to NetBox's API.\n\n    ## Parameters\n    * **data** (dict): Contains a dict that will be turned into a\n        json object and sent to the API.\n\n    ## Returns\n    Dict containing the response from NetBox's API.\n\n    ## Raises\n    * RequestError if req.ok returns false.\n    * ContentError if response is not json.\n    \"\"\"\n    return self._make_call(verb=\"patch\", data=data)\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.post","title":"<code>post(data)</code>","text":"<p>Makes POST request.</p> <p>Makes a POST request to NetBox's API.</p>"},{"location":"reference/core/query/#core.query.Request.post--parameters","title":"Parameters","text":"<ul> <li>data (dict): Contains a dict that will be turned into a     json object and sent to the API.</li> </ul>"},{"location":"reference/core/query/#core.query.Request.post--returns","title":"Returns","text":"<p>Dict containing the response from NetBox's API.</p>"},{"location":"reference/core/query/#core.query.Request.post--raises","title":"Raises","text":"<ul> <li>RequestError if req.ok returns false.</li> <li>AllocationError if req.status_code is 409 (Conflict)     as with available-ips and available-prefixes when there is     no room for the requested allocation.</li> <li>ContentError if response is not json.</li> </ul> Source code in <code>pyaci/core/query.py</code> <pre><code>def post(self, data):\n    \"\"\"Makes POST request.\n\n    Makes a POST request to NetBox's API.\n\n    ## Parameters\n    * **data** (dict): Contains a dict that will be turned into a\n        json object and sent to the API.\n\n    ## Returns\n    Dict containing the response from NetBox's API.\n\n    ## Raises\n    * RequestError if req.ok returns false.\n    * AllocationError if req.status_code is 409 (Conflict)\n        as with available-ips and available-prefixes when there is\n        no room for the requested allocation.\n    * ContentError if response is not json.\n    \"\"\"\n    return self._make_call(verb=\"post\", data=data)\n</code></pre>"},{"location":"reference/core/query/#core.query.Request.put","title":"<code>put(data)</code>","text":"<p>Makes PUT request.</p> <p>Makes a PUT request to NetBox's API.</p>"},{"location":"reference/core/query/#core.query.Request.put--parameters","title":"Parameters","text":"<ul> <li>data (dict): Contains a dict that will be turned into a     json object and sent to the API.</li> </ul>"},{"location":"reference/core/query/#core.query.Request.put--returns","title":"Returns","text":"<p>Dict containing the response from NetBox's API.</p>"},{"location":"reference/core/query/#core.query.Request.put--raises","title":"Raises","text":"<ul> <li>RequestError if req.ok returns false.</li> <li>ContentError if response is not json.</li> </ul> Source code in <code>pyaci/core/query.py</code> <pre><code>def put(self, data):\n    \"\"\"Makes PUT request.\n\n    Makes a PUT request to NetBox's API.\n\n    ## Parameters\n    * **data** (dict): Contains a dict that will be turned into a\n        json object and sent to the API.\n\n    ## Returns\n    Dict containing the response from NetBox's API.\n\n    ## Raises\n    * RequestError if req.ok returns false.\n    * ContentError if response is not json.\n    \"\"\"\n    return self._make_call(verb=\"put\", data=data)\n</code></pre>"},{"location":"reference/core/query/#core.query.RequestError","title":"<code>RequestError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Basic Request Exception.</p> <p>More detailed exception that returns the original requests object for inspection. Along with some attributes with specific details from the requests object. If return is json we decode and add it to the message.</p>"},{"location":"reference/core/query/#core.query.RequestError--examples","title":"Examples","text":"<pre><code>try:\n    nb.dcim.devices.create(name=\"destined-for-failure\")\nexcept pynetbox.RequestError as e:\n    print(e.error)\n</code></pre> Source code in <code>pyaci/core/query.py</code> <pre><code>class RequestError(Exception):\n    \"\"\"Basic Request Exception.\n\n    More detailed exception that returns the original requests object\n    for inspection. Along with some attributes with specific details\n    from the requests object. If return is json we decode and add it\n    to the message.\n\n    ## Examples\n\n    ```python\n    try:\n        nb.dcim.devices.create(name=\"destined-for-failure\")\n    except pynetbox.RequestError as e:\n        print(e.error)\n    ```\n    \"\"\"\n\n    def __init__(self, req):\n        if req.status_code == 404:\n            self.message = \"The requested url: {} could not be found.\".format(req.url)\n        else:\n            try:\n                self.message = \"The request failed with code {} {}: {}\".format(\n                    req.status_code, req.reason, req.json()\n                )\n            except ValueError:\n                self.message = (\n                    f\"The request failed with code {req.status_code} {req.reason} but more specific \"\n                    \"details were not returned in json. Check the ACI Logs \"\n                    \"or investigate this exception's error attribute.\"\n                )\n\n        super().__init__(self.message)\n        self.req = req\n        self.request_body = req.request.body\n        self.base = req.url\n        self.error = req.text\n\n    def __str__(self):\n        return self.message\n</code></pre>"},{"location":"reference/core/query/#core.query.calc_pages","title":"<code>calc_pages(limit, count)</code>","text":"<p>Calculate number of pages required for full results set.</p> Source code in <code>pyaci/core/query.py</code> <pre><code>def calc_pages(limit, count):\n    \"\"\"Calculate number of pages required for full results set.\"\"\"\n    return int(count / limit) + (limit % count &gt; 0)\n</code></pre>"},{"location":"reference/core/response/","title":"response","text":""},{"location":"reference/core/response/#core.response.JsonField","title":"<code>JsonField</code>","text":"<p>Explicit field type for values that are not to be converted to a Record object.</p> Source code in <code>pyaci/core/response.py</code> <pre><code>class JsonField:\n    \"\"\"Explicit field type for values that are not to be converted\n    to a Record object.\"\"\"\n\n    _json_field = True\n</code></pre>"},{"location":"reference/core/response/#core.response.Record","title":"<code>Record</code>","text":"<p>Create Python objects from ACI API responses.</p> <p>Creates an object from a ACI response passed as <code>values</code>. Nested dicts that represent other endpoints are also turned into Record objects. All fields are then assigned to the object's attributes. If a missing attr is requested (e.g. requesting a field that's only present on a full response on a Record made from a nested response) then pyACI will make a request for the full object and return the requested value.</p>"},{"location":"reference/core/response/#core.response.Record--examples","title":"Examples","text":"<p>Default representation of the object is usually its name:</p> <pre><code>x = aci.dcim.devices.get(1)\nx\n# test1-switch1\n</code></pre> <p>Querying a string field:</p> <pre><code>x = aci.dcim.devices.get(1)\nx.serial\n# 'ABC123'\n</code></pre> <p>Querying a field on a nested object:</p> <pre><code>x = aci.dcim.devices.get(1)\nx.device_type.model\n# 'QFX5100-24Q'\n</code></pre> <p>Casting the object as a dictionary:</p> <pre><code>from pprint import pprint\npprint(dict(x))\n{\n    'asset_tag': None,\n    'cluster': None,\n    'comments': '',\n    'config_context': {},\n    'created': '2018-04-01',\n    'custom_fields': {},\n    'role': {\n        'id': 1,\n        'name': 'Test Switch',\n        'slug': 'test-switch',\n        'url': 'http://localhost:8000/api/dcim/device-roles/1/'\n    },\n    'device_type': {...},\n    'display_name': 'test1-switch1',\n    'face': {'label': 'Rear', 'value': 1},\n    'id': 1,\n    'name': 'test1-switch1',\n    'parent_device': None,\n    'platform': {...},\n    'position': 1,\n    'primary_ip': {\n        'address': '192.0.2.1/24',\n        'family': 4,\n        'id': 1,\n        'url': 'http://localhost:8000/api/ipam/ip-addresses/1/'\n    },\n    'primary_ip4': {...},\n    'primary_ip6': None,\n    'rack': {\n        'display_name': 'Test Rack',\n        'id': 1,\n        'name': 'Test Rack',\n        'url': 'http://localhost:8000/api/dcim/racks/1/'\n    },\n    'site': {\n        'id': 1,\n        'name': 'TEST',\n        'slug': 'TEST',\n        'url': 'http://localhost:8000/api/dcim/sites/1/'\n    },\n    'status': {'label': 'Active', 'value': 1},\n    'tags': [],\n    'tenant': None,\n    'vc_position': None,\n    'vc_priority': None,\n    'virtual_chassis': None\n}\n</code></pre> <p>Iterating over a Record object:</p> <pre><code>for i in x:\n    print(i)\n\n# ('id', 1)\n# ('name', 'test1-switch1')\n# ('display_name', 'test1-switch1')\n</code></pre> Source code in <code>pyaci/core/response.py</code> <pre><code>class Record:\n    \"\"\"Create Python objects from ACI API responses.\n\n    Creates an object from a ACI response passed as `values`.\n    Nested dicts that represent other endpoints are also turned\n    into Record objects. All fields are then assigned to the\n    object's attributes. If a missing attr is requested\n    (e.g. requesting a field that's only present on a full response on\n    a Record made from a nested response) then pyACI will make a\n    request for the full object and return the requested value.\n\n    ## Examples\n\n    Default representation of the object is usually its name:\n\n    ```python\n    x = aci.dcim.devices.get(1)\n    x\n    # test1-switch1\n    ```\n\n    Querying a string field:\n\n    ```python\n    x = aci.dcim.devices.get(1)\n    x.serial\n    # 'ABC123'\n    ```\n\n    Querying a field on a nested object:\n\n    ```python\n    x = aci.dcim.devices.get(1)\n    x.device_type.model\n    # 'QFX5100-24Q'\n    ```\n\n    Casting the object as a dictionary:\n\n    ```python\n    from pprint import pprint\n    pprint(dict(x))\n    {\n        'asset_tag': None,\n        'cluster': None,\n        'comments': '',\n        'config_context': {},\n        'created': '2018-04-01',\n        'custom_fields': {},\n        'role': {\n            'id': 1,\n            'name': 'Test Switch',\n            'slug': 'test-switch',\n            'url': 'http://localhost:8000/api/dcim/device-roles/1/'\n        },\n        'device_type': {...},\n        'display_name': 'test1-switch1',\n        'face': {'label': 'Rear', 'value': 1},\n        'id': 1,\n        'name': 'test1-switch1',\n        'parent_device': None,\n        'platform': {...},\n        'position': 1,\n        'primary_ip': {\n            'address': '192.0.2.1/24',\n            'family': 4,\n            'id': 1,\n            'url': 'http://localhost:8000/api/ipam/ip-addresses/1/'\n        },\n        'primary_ip4': {...},\n        'primary_ip6': None,\n        'rack': {\n            'display_name': 'Test Rack',\n            'id': 1,\n            'name': 'Test Rack',\n            'url': 'http://localhost:8000/api/dcim/racks/1/'\n        },\n        'site': {\n            'id': 1,\n            'name': 'TEST',\n            'slug': 'TEST',\n            'url': 'http://localhost:8000/api/dcim/sites/1/'\n        },\n        'status': {'label': 'Active', 'value': 1},\n        'tags': [],\n        'tenant': None,\n        'vc_position': None,\n        'vc_priority': None,\n        'virtual_chassis': None\n    }\n    ```\n\n    Iterating over a Record object:\n\n    ```python\n    for i in x:\n        print(i)\n\n    # ('id', 1)\n    # ('name', 'test1-switch1')\n    # ('display_name', 'test1-switch1')\n    ```\n    \"\"\"\n\n    url = None\n\n    def __init__(self, values, api, endpoint):\n        self.has_details = False\n        self._full_cache = []\n        self._init_cache = []\n        self.api = api\n        self.default_ret = Record\n        self.endpoint = (\n            self._endpoint_from_url(values[\"url\"])\n            if values and \"url\" in values and values[\"url\"]\n            else endpoint\n        )\n        if values:\n            self._parse_values(values)\n</code></pre>"},{"location":"user_guide/installation/","title":"Installation","text":""},{"location":"user_guide/installation/#standard-installation","title":"Standard Installation","text":"<p>As outlined in the quick start, you should be able to pip install scrapli \"normally\":</p> <pre><code>pip install scrapli\n</code></pre>"},{"location":"user_guide/installation/#installing-current-main-branch","title":"Installing current main branch","text":"<p>To install from the source repositories master branch:</p> <pre><code>pip install git+https://github.com/carlmontanari/scrapli\n</code></pre>"},{"location":"user_guide/installation/#installing-a-different-branch","title":"Installing a different branch","text":"<p>To install from a different branch of the source repository, for example from a branch named <code>develop</code>:</p> <pre><code>pip install -e git+https://github.com/carlmontanari/scrapli.git@develop#egg=scrapli\n</code></pre>"},{"location":"user_guide/installation/#installation-from-source","title":"Installation from Source","text":"<p>To install from source:</p> <pre><code>git clone https://github.com/carlmontanari/scrapli\ncd scrapli\npython setup.py install\n</code></pre>"},{"location":"user_guide/installation/#optional-extras","title":"Optional Extras","text":"<p>scrapli has made an effort to have as few dependencies as possible -- in fact to have ZERO dependencies! The \"core\" of  scrapli can run with nothing other than standard library! If for any reason you wish to use paramiko, ssh2-python,  or asyncssh as a transport, however, you of course need to install those. These \"extras\" can be installed via pip:</p> <pre><code>pip install scrapli[paramiko]\n</code></pre> <p>The available optional installation extras options are:</p> <ul> <li>paramiko</li> <li>ssh2</li> <li>asyncssh  </li> <li>textfsm (textfsm and ntc-templates)</li> <li>ttp (ttp template parser)  </li> <li>genie (genie/pyats)</li> <li>netconf (scrapli_netconf)</li> <li>community (scrapli_community)</li> </ul> <p>If you would like to install all optional extras, you can do so with the <code>full</code> option:</p> <pre><code>pip install scrapli[full]\n</code></pre>"},{"location":"user_guide/installation/#supported-platforms","title":"Supported Platforms","text":"<p>As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any  POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no   longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or    ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks     to use WSL/Cygwin instead of Windows.</p>"},{"location":"user_guide/linting_testing/","title":"Installation","text":""},{"location":"user_guide/linting_testing/#standard-installation","title":"Standard Installation","text":"<p>As outlined in the quick start, you should be able to pip install scrapli \"normally\":</p> <pre><code>pip install scrapli\n</code></pre>"},{"location":"user_guide/linting_testing/#installing-current-main-branch","title":"Installing current main branch","text":"<p>To install from the source repositories master branch:</p> <pre><code>pip install git+https://github.com/carlmontanari/scrapli\n</code></pre>"},{"location":"user_guide/linting_testing/#installing-a-different-branch","title":"Installing a different branch","text":"<p>To install from a different branch of the source repository, for example from a branch named <code>develop</code>:</p> <pre><code>pip install -e git+https://github.com/carlmontanari/scrapli.git@develop#egg=scrapli\n</code></pre>"},{"location":"user_guide/linting_testing/#installation-from-source","title":"Installation from Source","text":"<p>To install from source:</p> <pre><code>git clone https://github.com/carlmontanari/scrapli\ncd scrapli\npython setup.py install\n</code></pre>"},{"location":"user_guide/linting_testing/#optional-extras","title":"Optional Extras","text":"<p>scrapli has made an effort to have as few dependencies as possible -- in fact to have ZERO dependencies! The \"core\" of  scrapli can run with nothing other than standard library! If for any reason you wish to use paramiko, ssh2-python,  or asyncssh as a transport, however, you of course need to install those. These \"extras\" can be installed via pip:</p> <pre><code>pip install scrapli[paramiko]\n</code></pre> <p>The available optional installation extras options are:</p> <ul> <li>paramiko</li> <li>ssh2</li> <li>asyncssh  </li> <li>textfsm (textfsm and ntc-templates)</li> <li>ttp (ttp template parser)  </li> <li>genie (genie/pyats)</li> <li>netconf (scrapli_netconf)</li> <li>community (scrapli_community)</li> </ul> <p>If you would like to install all optional extras, you can do so with the <code>full</code> option:</p> <pre><code>pip install scrapli[full]\n</code></pre>"},{"location":"user_guide/linting_testing/#supported-platforms","title":"Supported Platforms","text":"<p>As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any  POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no   longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or    ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks     to use WSL/Cygwin instead of Windows.</p>"},{"location":"user_guide/quickstart/","title":"Quick Start Guide","text":""},{"location":"user_guide/quickstart/#installation","title":"Installation","text":"<p>In most cases installation via pip is the simplest and best way to install scrapli. See here for advanced installation details.</p> <pre><code>pip install scrapli\n</code></pre>"},{"location":"user_guide/quickstart/#a-simple-example","title":"A Simple Example","text":"<pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXEDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show run\")\nprint(response.result)\n</code></pre> <pre><code>$ python my_scrapli_script.py\nBuilding configuration...\n\nCurrent configuration : 7584 bytes\n!\n! Last configuration change at 19:24:38 PST Sat Feb 29 2020 by carl\n! NVRAM config last updated at 19:00:28 PST Fri Feb 7 2020 by carl\n!\nversion 15.2\nservice nagle\nno service pad\nservice tcp-keepalives-in\nservice tcp-keepalives-out\nservice timestamps debug datetime msec\nno service password-encryption\n!\n&lt;SNIP&gt;\n!\nend\n</code></pre>"}]}